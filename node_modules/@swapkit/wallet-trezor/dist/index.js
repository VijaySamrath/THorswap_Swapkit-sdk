var C=Object.defineProperty;var v=(Q,V)=>{for(var D in V)C(Q,D,{get:V[D],enumerable:!0,configurable:!0,set:(_)=>V[D]=()=>_})};var g=(Q,V)=>()=>(Q&&(V=Q(Q=0)),V);var R=((Q)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(Q,{get:(V,D)=>(typeof require!=="undefined"?require:V)[D]}):Q)(function(Q){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+Q+'" is not supported')});var y={};v(y,{getEVMSigner:()=>l});import{ChainToChainId as u,SwapKitError as W,SwapKitNumber as P,WalletOption as m,derivationPathToString as S} from"@swapkit/helpers";async function l({chain:Q,derivationPath:V,provider:D}){const{AbstractSigner:_}=await import("@swapkit/toolbox-evm");class O extends _{address;chain;derivationPath;provider;constructor({chain:J,derivationPath:Z,provider:X}){super(X);this.address="",this.chain=J,this.derivationPath=Z,this.provider=X}getAddress=async()=>{if(!this.address){const{default:J}=await import("@trezor/connect-web"),Z=await J.ethereumGetAddress({path:S(this.derivationPath),showOnTrezor:!0});if(!Z.success)throw new W({errorKey:"wallet_trezor_failed_to_get_address",info:{...Z,chain:this.chain,derivationPath:this.derivationPath}});this.address=Z.payload.address}return this.address};signMessage=async(J)=>{const{default:Z}=await import("@trezor/connect-web"),X=await Z.ethereumSignMessage({path:S(this.derivationPath),message:J});if(!X.success)throw new W({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...X,message:J,chain:this.chain,derivationPath:this.derivationPath}});return X.payload.signature};signTypedData(){throw new Error("Not implemented")}signTransaction=async({to:J,gasLimit:Z,value:X,data:A,nonce:E,maxFeePerGas:N,maxPriorityFeePerGas:$,gasPrice:B})=>{if(!J)throw new W({errorKey:"wallet_missing_params",info:{to:J}});if(!Z)throw new W({errorKey:"wallet_missing_params",info:{gasLimit:Z}});const q=N&&$;if(q&&!N)throw new W({errorKey:"wallet_missing_params",info:{maxFeePerGas:N}});if(q&&!$)throw new W({errorKey:"wallet_missing_params",info:{maxPriorityFeePerGas:$}});if(!(q||B))throw new W({errorKey:"wallet_missing_params",info:{gasPrice:B}});const{default:b}=await import("@trezor/connect-web"),{Transaction:f,toHexString:k}=await import("@swapkit/toolbox-evm"),K=q?{maxFeePerGas:k(BigInt(N?.toString()||0)),maxPriorityFeePerGas:k(BigInt($?.toString()||0))}:B&&{gasPrice:k(BigInt(B?.toString()||0))}||{gasPrice:"0x0"},M={chainId:Number.parseInt(u[this.chain]),to:J.toString(),value:k(BigInt(X?.toString()||0)),gasLimit:k(BigInt(Z?.toString()||0)),nonce:(E?.toString()||await this.provider.getTransactionCount(await this.getAddress(),"pending")).toString(),data:A?.toString()||"0x",...K},{success:I,payload:G}=await b.ethereumSignTransaction({path:S(this.derivationPath),transaction:M});if(!I)throw new W({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...G,chain:this.chain,derivationPath:this.derivationPath}});const{r:L,s:H,v:z}=G,Y=f.from({...M,nonce:Number.parseInt(M.nonce),type:q?2:0,signature:{r:L,s:H,v:new P(z).getBaseValue("number")}}).serialized;if(!Y)throw new W({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{chain:this.chain,derivationPath:this.derivationPath}});return Y};connect=(J)=>{if(!J)throw new W({errorKey:"wallet_provider_not_found",info:{wallet:m.TREZOR,chain:this.chain,derivationPath:this.derivationPath}});return new O({chain:this.chain,derivationPath:this.derivationPath,provider:J})}}return new O({chain:Q,derivationPath:V,provider:D})}var x=g(()=>{});import{Chain as j,FeeOption as d,SwapKitError as U,WalletOption as T,derivationPathToString as c,setRequestClientConfig as h} from"@swapkit/helpers";var s=function(Q){switch(Q[0]){case 84:return{input:"SPENDWITNESS",output:"PAYTOWITNESS"};case 49:return{input:"SPENDP2SHWITNESS",output:"PAYTOP2SHWITNESS"};case 44:return{input:"SPENDADDRESS",output:"PAYTOADDRESS"};default:return null}};async function p({api:Q,rpcUrl:V,chain:D,ethplorerApiKey:_,covalentApiKey:O,derivationPath:J,blockchairApiKey:Z}){switch(D){case j.BinanceSmartChain:case j.Avalanche:case j.Arbitrum:case j.Optimism:case j.Polygon:case j.Ethereum:{if(D===j.Ethereum&&!_)throw new U({errorKey:"wallet_missing_api_key",info:{missingKey:"ethplorerApiKey"}});if(D!==j.Ethereum&&!O)throw new U({errorKey:"wallet_missing_api_key",info:{missingKey:"covalentApiKey"}});const{getProvider:X,getToolboxByChain:A}=await import("@swapkit/toolbox-evm"),{getEVMSigner:E}=await Promise.resolve().then(() => (x(),y)),N=X(D,V),$=await E({chain:D,derivationPath:J,provider:N}),B=await $.getAddress(),q=A(D);return{address:B,walletMethods:{...q({api:Q,covalentApiKey:O,ethplorerApiKey:_,provider:N,signer:$})}}}case j.Bitcoin:case j.BitcoinCash:case j.Dash:case j.Dogecoin:case j.Litecoin:{if(!(Z||Q))throw new U({errorKey:"wallet_missing_api_key",info:{missingKey:"blockchairApiKey"}});const{toCashAddress:X,getToolboxByChain:A,BCHToolbox:E}=await import("@swapkit/toolbox-utxo"),N=s(J);if(!N)throw new U({errorKey:"wallet_trezor_derivation_path_not_supported",info:{derivationPath:J}});const $=D.toLowerCase(),B={apiClient:Q,apiKey:Z,rpcUrl:V},q=A(D)(B),f=await(async(M=J)=>{const{default:I}=await import("@trezor/connect-web"),{success:G,payload:L}=await I.getAddress({path:c(M),coin:$});if(!G)throw new U({errorKey:"wallet_trezor_failed_to_get_address",info:{chain:D,error:L.error||"Unknown error"}});return D===j.BitcoinCash?q.stripPrefix(L.address):L.address})(),k=async(M,I,G="")=>{const{default:L}=await import("@trezor/connect-web"),H=J.map((Y,F)=>F<3?(Y|2147483648)>>>0:Y),z=await L.signTransaction({coin:$,inputs:I.map((Y)=>({address_n:H,prev_hash:Y.hash,prev_index:Y.index,amount:Y.value,script_type:N.input})),outputs:M.txOutputs.map((Y)=>{const F=D===j.BitcoinCash&&Y.address?X(Y.address):Y.address,w=D===j.BitcoinCash&&F?q.stripPrefix(F)===f:F===f;if(!Y.address)return{amount:"0",op_return_data:Buffer.from(G).toString("hex"),script_type:"PAYTOOPRETURN"};if(w)return{address_n:H,amount:Y.value,script_type:N.output};return{address:F,amount:Y.value,script_type:"PAYTOADDRESS"}})});if(z.success)return z.payload.serializedTx;throw new U({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{chain:D,error:z.payload.error}})};return{address:f,walletMethods:{...q,transfer:async({from:M,recipient:I,feeOptionKey:G,feeRate:L,memo:H,...z})=>{if(!M)throw new U({errorKey:"wallet_missing_params",info:{wallet:T.TREZOR,memo:H,from:M}});if(!I)throw new U({errorKey:"wallet_missing_params",info:{wallet:T.TREZOR,memo:H,recipient:I}});const{psbt:Y,inputs:F}=await q.buildTx({...z,memo:H,recipient:I,feeRate:L||(await q.getFeeRates())[G||d.Fast],sender:M,fetchTxHex:D===j.Dogecoin}),w=await k(Y,F,H);return q.broadcastTx(w)},signTransaction:k}}}default:throw new U({errorKey:"wallet_chain_not_supported",info:{chain:D,wallet:T.TREZOR}})}}var n=function({apis:Q,rpcUrls:V,addChain:D,config:{covalentApiKey:_,ethplorerApiKey:O,blockchairApiKey:J,trezorManifest:Z={appUrl:"",email:""},thorswapApiKey:X}}){return async function A(E,N){const $=E[0];if(!$)return!1;h({apiKey:X});const{default:B}=await import("@trezor/connect-web"),{success:q}=await B.getDeviceState();if(!q)B.init({lazyLoad:!0,manifest:Z});const{address:b,walletMethods:f}=await p({api:Q[$],rpcUrl:V[$],chain:$,covalentApiKey:_,ethplorerApiKey:O,blockchairApiKey:J,derivationPath:N});return D({chain:$,...f,address:b,balance:[],walletType:T.TREZOR}),!0}},r=[j.Arbitrum,j.Avalanche,j.BinanceSmartChain,j.Bitcoin,j.BitcoinCash,j.Dash,j.Dogecoin,j.Ethereum,j.Litecoin,j.Optimism,j.Polygon],i={connectTrezor:n};export{i as trezorWallet,r as TREZOR_SUPPORTED_CHAINS};

//# debugId=C47C28E6C0BE98F264756E2164756E21
