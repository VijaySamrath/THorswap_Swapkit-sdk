var L=((z)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(z,{get:(Y,Z)=>(typeof require!=="undefined"?require:Y)[Z]}):z)(function(z){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+z+'" is not supported')});import{Chain as Q,ChainToChainId as b,ChainToHexChainId as u,ChainToRPC as m,SwapKitError as I,WalletOption as f,setRequestClientConfig as d} from"@swapkit/helpers";import{Chain as q,ChainToChainId as K,EVMChains as g,RPCUrl as x,SwapKitError as X,WalletOption as T,erc20ABI as w} from"@swapkit/helpers";import{getDenom as v} from"@swapkit/toolbox-cosmos";function H(z){if(!window.xfi)throw new X("wallet_xdefi_not_found");switch(z){case q.Ethereum:case q.Avalanche:case q.BinanceSmartChain:case q.Arbitrum:case q.Optimism:case q.Polygon:return window.xfi.ethereum;case q.Cosmos:case q.Kujira:return window.xfi.keplr;case q.Bitcoin:return window.xfi.bitcoin;case q.BitcoinCash:return window.xfi.bitcoincash;case q.Dogecoin:return window.xfi.dogecoin;case q.Litecoin:return window.xfi.litecoin;case q.THORChain:return window.xfi.thorchain;case q.Maya:return window.xfi.mayachain;case q.Solana:return window.xfi.solana;default:return}}async function A({method:z,params:Y,chain:Z}){const J=H(Z);return new Promise(($,G)=>{if(J&&"request"in J)J.request({method:z,params:Y},(R,_)=>{R?G(R):$(_)})})}async function k(z){const Y=H(z);if(!Y)throw new X({errorKey:"wallet_provider_not_found",info:{wallet:T.XDEFI,chain:z}});if([q.Cosmos,q.Kujira].includes(z)){const Z=H(q.Cosmos);if(!Z||"request"in Z)throw new X({errorKey:"wallet_provider_not_found",info:{wallet:T.XDEFI,chain:z}});const J=K[z];await Z.enable(J);const $=Z.getOfflineSigner(J),[G]=await $.getAccounts();return G?.address}if(g.includes(z)){const[Z]=await Y.request({method:"eth_requestAccounts",params:[]});return Z}if(z===q.Solana)return(await H(q.Solana).connect()).publicKey.toString();return new Promise((Z,J)=>Y.request({method:"request_accounts",params:[]},($,[G])=>$?J($):Z(G)))}async function M({assetValue:z,recipient:Y,memo:Z,gasLimit:J},$="transfer"){if(!z)throw new X("wallet_xdefi_asset_not_defined");const G=await k(z.chain),R=[{amount:{amount:z.getBaseValue("number"),decimals:z.decimal},asset:{chain:z.chain,symbol:z.symbol.toUpperCase(),ticker:z.symbol.toUpperCase()},memo:Z,from:G,recipient:Y,gasLimit:J}];return A({method:$,params:R,chain:z.chain})}function y({chainId:z,rpcUrl:Y}){return async({from:Z,recipient:J,assetValue:$,memo:G})=>{const{createSigningStargateClient:R}=await import("@swapkit/toolbox-cosmos"),_=window.xfi?.keplr?.getOfflineSignerOnlyAmino(z),U=await R(Y||x.Cosmos,_),j=[{denom:v(`u${$.symbol}`).toLowerCase(),amount:$.getBaseValue("string")}],{transactionHash:B}=await U.sendTokens(Z,J,j,2,G);return B}}function S(z){return{call:async({contractAddress:Y,abi:Z,funcName:J,funcParams:$=[],txOverrides:G})=>{const R=z;if(!Y)throw new X("wallet_xdefi_contract_address_not_provided");const{createContract:_,createContractTxObject:U,isStateChangingCall:j,toHexString:B}=await import("@swapkit/toolbox-evm");if(j(Z,J)){const{value:F,from:O,to:P,data:E}=await U(R,{contractAddress:Y,abi:Z,funcName:J,funcParams:$,txOverrides:G});return z.send("eth_sendTransaction",[{value:B(BigInt(F||0)),from:O,to:P,data:E||"0x"}])}const W=await _(Y,Z,R)[J]?.(...$);return typeof W?.hash==="string"?W?.hash:W},approve:async({assetAddress:Y,spenderAddress:Z,amount:J,from:$})=>{const{MAX_APPROVAL:G,createContractTxObject:R,toHexString:_}=await import("@swapkit/toolbox-evm"),U=[Z,BigInt(J||G)],B={contractAddress:Y,abi:w,funcName:"approve",funcParams:U,txOverrides:{from:$}},{value:N,to:D,data:W}=await R(z,B);return z.send("eth_sendTransaction",[{value:_(BigInt(N||0)),from:$,to:D,data:W||"0x"}])},sendTransaction:async(Y)=>{const{from:Z,to:J,data:$,value:G}=Y;if(!J)throw new X("wallet_xdefi_send_transaction_no_address");const{toHexString:R}=await import("@swapkit/toolbox-evm");return z.send("eth_sendTransaction",[{value:R(BigInt(G||0)),from:Z,to:J,data:$||"0x"}])}}}async function p({chain:z,blockchairApiKey:Y,covalentApiKey:Z,ethplorerApiKey:J}){switch(z){case Q.Solana:{const{SOLToolbox:$}=await import("@swapkit/toolbox-solana");return{...$(),transfer:M}}case Q.Maya:case Q.THORChain:{const{getToolboxByChain:$,THORCHAIN_GAS_VALUE:G,MAYA_GAS_VALUE:R}=await import("@swapkit/toolbox-cosmos"),_=z===Q.Maya?R:G;return{...$(z)(),deposit:(j)=>M({...j,recipient:""},"deposit"),transfer:(j)=>M({...j,gasLimit:_},"transfer")}}case Q.Cosmos:case Q.Kujira:{const{getToolboxByChain:$}=await import("@swapkit/toolbox-cosmos");return{...$(z)(),transfer:y({chainId:b[z],rpcUrl:m[z]})}}case Q.Bitcoin:case Q.BitcoinCash:case Q.Dogecoin:case Q.Litecoin:{const{getToolboxByChain:$}=await import("@swapkit/toolbox-utxo");return{...$(z)({apiKey:Y}),transfer:M}}case Q.Ethereum:case Q.BinanceSmartChain:case Q.Arbitrum:case Q.Optimism:case Q.Polygon:case Q.Avalanche:{const{prepareNetworkSwitch:$,addEVMWalletNetwork:G}=await import("@swapkit/helpers"),{getProvider:R,getToolboxByChain:_,covalentApi:U,ethplorerApi:j,getBalance:B,BrowserProvider:N}=await import("@swapkit/toolbox-evm"),D=H(z);if(!D)throw new I("wallet_xdefi_not_found");if(z!==Q.Ethereum&&!Z||z===Q.Ethereum&&!J)throw new I({errorKey:"wallet_missing_api_key",info:{missingKey:z===Q.Ethereum?"ethplorerApiKey":"covalentApiKey",chain:z}});const W=new N(D,"any"),F=_(z)({provider:W,signer:await W.getSigner(),ethplorerApiKey:J||"",covalentApiKey:Z||""}),O=S(W);try{z!==Q.Ethereum&&await G(D,F.getNetworkParams())}catch(E){throw new I({errorKey:"wallet_failed_to_add_or_switch_network",info:{wallet:f.XDEFI,chain:z}})}const P=z===Q.Ethereum?j(J):U({apiKey:Z,chainId:b[z]});return $({provider:window.xfi?.ethereum,chainId:u[z],toolbox:{...F,...O,getBalance:(E,V)=>B({chain:z,provider:R(z),api:P,address:E,potentialScamFilter:V})}})}default:return null}}var C=function({addChain:z,config:{covalentApiKey:Y,ethplorerApiKey:Z,blockchairApiKey:J,thorswapApiKey:$}}){return async(G)=>{d({apiKey:$});const R=G.map(async(_)=>{const U=await k(_),j=await p({chain:_,blockchairApiKey:J,covalentApiKey:Y,ethplorerApiKey:Z});z({...j,address:U,balance:[],chain:_,walletType:f.XDEFI})});return await Promise.all(R),!0}},n=[Q.Arbitrum,Q.Avalanche,Q.BinanceSmartChain,Q.Bitcoin,Q.BitcoinCash,Q.Cosmos,Q.Dogecoin,Q.Ethereum,Q.Kujira,Q.Litecoin,Q.Maya,Q.Optimism,Q.Polygon,Q.Solana,Q.THORChain],l={connectXDEFI:C};export{l as xdefiWallet};

//# debugId=EAC8575ABE680EA864756E2164756E21
