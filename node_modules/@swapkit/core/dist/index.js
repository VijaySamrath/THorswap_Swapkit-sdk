var i=((X)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(X,{get:(Q,j)=>(typeof require!=="undefined"?require:Q)[j]}):X)(function(X){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+X+'" is not supported')});export*from"@swapkit/api";export*from"@swapkit/helpers";import{stripToCashAddress as k$} from"@swapkit/toolbox-utxo";import{lowercasedContractAbiMapping as N} from"@swapkit/contracts";import{ApproveMode as D,AssetValue as k,Chain as R,EVMChains as s,ProviderName as t,SwapKitError as Y,isGasAsset as l} from"@swapkit/helpers";import{estimateTransactionFee as e,cosmosValidateAddress as a} from"@swapkit/toolbox-cosmos";import{evmValidateAddress as $$} from"@swapkit/toolbox-evm";import{substrateValidateAddress as _$} from"@swapkit/toolbox-substrate";import{utxoValidateAddress as L$} from"@swapkit/toolbox-utxo";import{Chain as I,ChainToExplorerUrl as E,SwapKitError as n} from"@swapkit/helpers";function M({chain:X,txHash:Q}){const j=E[X];switch(X){case I.Maya:case I.Kujira:case I.Cosmos:case I.THORChain:case I.Solana:return`${j}/tx/${Q.startsWith("0x")?Q.slice(2):Q}`;case I.Arbitrum:case I.Avalanche:case I.BinanceSmartChain:case I.Ethereum:case I.Optimism:case I.Polkadot:case I.Polygon:return`${j}/tx/${Q.startsWith("0x")?Q:`0x${Q}`}`;case I.Litecoin:case I.Bitcoin:case I.BitcoinCash:case I.Dogecoin:return`${j}/transaction/${Q.toLowerCase()}`;default:throw new n({errorKey:"core_explorer_unsupported_chain",info:{chain:X}})}}function O({chain:X,address:Q}){const j=E[X];switch(X){case I.Solana:return`${j}/account/${Q}`;default:return`${j}/address/${Q}`}}function j$({apis:X={},config:Q={},plugins:j,rpcUrls:f={},stagenet:S=!1,wallets:b={}}){const B={},H=Object.entries(j).reduce(($,[_,{plugin:L,config:q}])=>{const z=L({getWallet:U,stagenet:S,config:q??Q});return $[_]=z,$},{}),v=Object.entries(b).reduce(($,[_,L])=>{const q=L({addChain:W,config:Q,apis:X,rpcUrls:f});return $[_]=q,$},{});function K($){const _=H[$]||Object.values(H)[0];if(!_)throw new Y("core_plugin_not_found");return _}function y($){const _=Object.values(H).find((L)=>L.supportedSwapkitProviders?.includes($));if(!_)throw new Y("core_plugin_not_found");return _}function W($){const _=U($.chain);B[$.chain]={..._,...$}}function F({assetValue:$,type:_="checkOnly",contractAddress:L}){const q=H[L];if(q){if(_===D.CheckOnly&&"isAssetValueApproved"in q)return q.isAssetValueApproved({assetValue:$});if(_===D.Approve&&"approveAssetValue"in q)return q.approveAssetValue({assetValue:$});throw new Y({errorKey:"core_approve_asset_target_invalid",info:{message:`Target ${String(L)} cannot be used for approve operation`}})}const z=$.chain,x=s.includes(z);if(x&&$.isGasAsset||!x||$.isSynthetic)return Promise.resolve(_==="checkOnly"?!0:"approved");const Z=U(z),G=_==="checkOnly"?Z.isApproved:Z.approve;if(!G)throw new Y("core_wallet_connection_not_found");if(!($.address&&Z.address&&typeof L==="string"))throw new Y("core_approve_asset_address_or_from_not_found");return G({amount:$.getBaseValue("bigint"),assetAddress:$.address,from:Z.address,spenderAddress:L})}function U($){return B[$]}function C(){return{...B}}function A($){return U($)?.address||""}function V($,_){return F({assetValue:$,contractAddress:_,type:D.Approve})}function m($,_){return F({assetValue:$,contractAddress:_,type:D.CheckOnly})}function P($){U($)?.disconnect?.(),delete B[$]}function w(){for(let $ of Object.keys(B))P($)}function u($,_){return _?T($).then(({balance:L})=>L):U($)?.balance||[]}function g({address:$,chain:_}){switch(_){case R.Arbitrum:case R.Avalanche:case R.Optimism:case R.BinanceSmartChain:case R.Polygon:case R.Ethereum:return $$({address:$});case R.Litecoin:case R.Dash:case R.Dogecoin:case R.BitcoinCash:case R.Bitcoin:return L$({address:$,chain:_});case R.Cosmos:case R.Kujira:case R.Maya:case R.THORChain:return a({address:$,chain:_});case R.Polkadot:return _$({address:$,chain:_});default:return!1}}async function T($,_=!0){const L=[k.from({chain:$})],q=U($);if(!q)throw new Y("core_wallet_connection_not_found");if("getBalance"in q){const z=await q.getBalance(q.address,_);q.balance=z?.length?z:L}return q}function o({route:$,pluginName:_,...L}){const q=_&&K(_)||y($.providers[0]);if(!q)throw new Y("core_swap_route_not_complete");if("swap"in q)return q.swap({...L,route:$});throw new Y("core_plugin_swap_not_found")}function h({from:$,recipient:_,assetValue:L,feeOptionKey:q}){const z=L.chain,x=U(z);if(!x)throw new Y("core_wallet_connection_not_found");return x.transfer({from:$,recipient:_,assetValue:L,feeOptionKey:q})}function d({chain:$,message:_}){const L=U($);if(!L)throw new Y("core_wallet_connection_not_found");if("signMessage"in L)return L.signMessage?.(_);throw new Y({errorKey:"core_wallet_sign_message_not_supported",info:{chain:$,wallet:L.walletType}})}async function r({address:$,chain:_,message:L,signature:q}){switch(_){case R.THORChain:{const{getToolboxByChain:z}=await import("@swapkit/toolbox-cosmos");return z(_)().verifySignature({signature:q,message:L,address:$})}default:throw new Y({errorKey:"core_verify_message_not_supported",info:{chain:_}})}}async function c({type:$,feeOptionKey:_,params:L}){const{assetValue:q}=L,{chain:z}=q;if(!U(z))throw new Y("core_wallet_connection_not_found");const x=k.from({chain:z});switch(z){case R.Arbitrum:case R.Avalanche:case R.Ethereum:case R.BinanceSmartChain:case R.Polygon:{const J=U(z);if($==="transfer"){const Z=await J.createTransferTx(L);return J.estimateTransactionFee(Z,_)}if($==="approve"&&!l(q))return J.estimateTransactionFee(await J.createApprovalTx({assetAddress:q.address,spenderAddress:L.contractAddress,amount:q.getBaseValue("bigint"),from:J.address}),_);if($==="swap"){if(L.route.providers[0]===t.CHAINFLIP){const p=await J.createTransferTx({from:J.address,recipient:J.address,assetValue:q});return J.estimateTransactionFee(p,_)}const{evmTransactionDetails:G}=L.route;if(!(G&&N[G.contractAddress]))return;return J.estimateTransactionFee(await J.createContractTxObject({contractAddress:G.contractAddress,abi:N[G.contractAddress],funcName:G.contractMethod,funcParams:G.contractParams}),_)}return k.from({chain:z})}case R.Bitcoin:case R.BitcoinCash:case R.Dogecoin:case R.Dash:case R.Litecoin:{const{estimateMaxSendableAmount:J,address:Z}=U(z);return J({...L,feeOptionKey:_,from:Z,recipient:Z})}case R.THORChain:case R.Maya:case R.Kujira:case R.Cosmos:return e(L);case R.Polkadot:{const{address:J,estimateTransactionFee:Z}=U(z);return Z({...L,recipient:J})}default:return x}}return{...H,...v,disconnectAll:w,disconnectChain:P,estimateTransactionFee:c,getAddress:A,getAllWallets:C,getBalance:u,getExplorerAddressUrl:O,getExplorerTxUrl:M,getWallet:U,getWalletWithBalance:T,approveAssetValue:V,isAssetValueApproved:m,signMessage:d,swap:o,transfer:h,validateAddress:g,verifyMessage:r}}export{k$ as stripToCashAddress,j$ as SwapKit};

//# debugId=829B2312977B2D9D64756E2164756E21
