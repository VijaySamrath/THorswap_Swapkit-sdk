import{lowercasedContractAbiMapping as b} from"@swapkit/contracts";import{ApproveMode as Z,AssetValue as f,EVMChains as _,ProviderName as q,SwapKitError as Q} from"@swapkit/helpers";var S=function({getWallet:R}){async function $({route:x,feeOptionKey:J}){const{evmTransactionDetails:j,sellAmount:B,sellAsset:F}=x,H=j&&b[j.contractAddress],z=(await f.from({asset:F,value:B,asyncTokenLookup:!0})).chain;if(!(_.includes(z)&&H))throw new Q("core_swap_invalid_params");const L=R(z);return L.call({contractAddress:j.contractAddress,funcName:j.contractMethod,funcParams:j.contractParams,txOverrides:{from:L.address},feeOption:J,abi:H})}function U({assetValue:x,spenderAddress:J,type:j="checkOnly"}){const{address:B,chain:F,isGasAsset:H,isSynthetic:X}=x,z=_.includes(F);if(z&&H||!z||X)return Promise.resolve(j==="checkOnly"?!0:"approved");const I=R(F);if(!I)throw new Q("core_wallet_connection_not_found");const O=j==="checkOnly"?I.isApproved:I.approve,Y=I.address;if(!(B&&Y))throw new Q("core_approve_asset_address_or_from_not_found");return O({amount:x.getBaseValue("bigint"),assetAddress:B,from:Y,spenderAddress:J})}function G(x){return U({...x,type:Z.Approve})}function k(x){return U({...x,type:Z.CheckOnly})}return{swap:$,approveAssetValue:G,isAssetValueApproved:k,supportedSwapkitProviders:[q.TRADERJOE_V1,q.PANGOLIN_V1,q.UNISWAP_V2,q.SUSHISWAP_V2,q.ONEINCH,q.WOOFI_V2,q.PANCAKESWAP]}},T={evm:{plugin:S}};export{T as EVMPlugin};

//# debugId=6D625CC6532219B664756E2164756E21
