var n=((U)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(U,{get:(D,_)=>(typeof require!=="undefined"?require:D)[_]}):U)(function(U){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+U+'" is not supported')});import{lowercasedContractAbiMapping as B1} from"@swapkit/contracts";import{AGG_SWAP as I1,AssetValue as a,Chain as K,ChainToChainId as k1,FeeOption as e,MemoType as z1,ProviderName as H1,SWAP_IN as D1,SWAP_OUT as F1,SwapKitError as k,SwapKitNumber as f1,TCAvalancheDepositABI as v1,TCBscDepositABI as E1,TCEthereumVaultAbi as W1,getMemoForLoan as K1} from"@swapkit/helpers";import{SwapKitApi as t} from"@swapkit/api";import{ApproveMode as i,AssetValue as Z1,Chain as l,EVMChains as $1,FeeOption as c,MemoType as r,SwapKitError as T,getMemoForDeposit as A,getMemoForLeaveAndBond as Y1,getMemoForNamePreferredAssetRegister as j1,getMemoForNameRegister as U1,getMemoForSaverDeposit as _1,getMemoForSaverWithdraw as G1,getMemoForUnbond as R1,getMemoForWithdraw as N1,getMinAmountByChain as u,wrapWithThrow as V} from"@swapkit/helpers";var O1=function(U){return async function D(_){if(U.type==="thorchain"&&_===l.THORChain||U.type==="mayachain"&&_===l.Maya)return{gas_rate:"0",router:"",address:"",halted:!1,chain:_};const B=(await t.getInboundAddresses(U)).find((f)=>f.chain===_);if(!B)throw new T("core_inbound_data_not_found");if(B?.halted)throw new T("core_chain_halted");return B}};function m({stagenet:U,deposit:D,pluginChain:_,getWallet:L}){const B=_===l.Maya?"mayachain":"thorchain",f=O1({stagenet:U,type:B});async function M({assetValue:z,type:H="checkOnly"}){const X=(await f(z.chain)).router,J=z.chain,Z=$1.includes(J);if(Z&&z.isGasAsset||!Z||z.isSynthetic)return Promise.resolve(H==="checkOnly"?!0:"approved");const Y=L(J);if(!Y)throw new T("core_wallet_connection_not_found");const R=H==="checkOnly"?Y.isApproved:Y.approve;if(!(z.address&&Y.address))throw new T("core_approve_asset_address_or_from_not_found");return R({amount:z.getBaseValue("bigint"),assetAddress:z.address,from:Y.address,spenderAddress:X})}async function E({memo:z,assetValue:H}){const X=await t.getMimirInfo({stagenet:U,type:B});if(X.HALTCHAINGLOBAL>=1||X.HALTTHORCHAIN>=1)throw new T("thorchain_chain_halted");return D({assetValue:H,recipient:"",memo:z})}async function I({assetValue:z,memo:H,feeOptionKey:X=c.Fast}){const{gas_rate:J="0",router:Z,address:j}=await f(z.chain);return D({assetValue:z,recipient:j,memo:H,router:Z,feeRate:Number.parseInt(J)*L1[X]})}function S(z){return M({...z,type:i.Approve})}function b(z){return M({...z,type:i.CheckOnly})}function N({assetValue:z,...H}){return E({assetValue:z,memo:U1(H)})}function q({assetValue:z,payoutAddress:H,name:X,ownerAddress:J}){const Z=H||L(z.chain).address;return E({assetValue:z,memo:j1({asset:z.toString(),chain:z.chain,name:X,owner:J,payout:Z})})}function F({type:z,assetValue:H,address:X}){const J=z===r.UNBOND?R1({address:X,unbondAmount:H.getBaseValue("number")}):Y1({type:z,address:X}),Z=z===r.BOND?H:u(_);return E({memo:J,assetValue:Z})}async function W({baseAssetValue:z,assetValue:H}){if(z.lte(0)||H.lte(0))throw new T("core_transaction_create_liquidity_invalid_params");const X=L(H.chain).address,J=L(_).address,Z=await V(()=>{return I({assetValue:z,memo:A({...H,address:X})})},"core_transaction_create_liquidity_base_error"),j=await V(()=>{return I({assetValue:H,memo:A({...H,address:J})})},"core_transaction_create_liquidity_asset_error");return{baseAssetTx:Z,assetTx:j}}function Q({assetValue:z,poolAddress:H,address:X,symmetric:J}){if(J&&!X)throw new T("core_transaction_add_liquidity_invalid_params");const Z=A({chain:H.split(".")[0],symbol:H.split(".")[1],address:J?X:""});return I({assetValue:z,memo:Z})}async function $({baseAssetValue:z,assetValue:H,baseAssetAddr:X,assetAddr:J,isPendingSymmAsset:Z,mode:j="sym"}){const{chain:Y,symbol:R}=H,x=j==="sym",v=z?.gt(0)&&(x||j==="baseAsset"),P=H?.gt(0)&&(x||j==="asset"),C=Z||v,g=L(_).address,o=C?X||g:"",J1=x||j==="asset"?J||L(Y).address:"";if(!(v||P))throw new T("core_transaction_add_liquidity_invalid_params");if(C&&!o)throw new T("core_transaction_add_liquidity_base_address");const Q1=v&&z?await V(()=>{return I({assetValue:z,memo:A({chain:Y,symbol:R,address:J1})})},"core_transaction_add_liquidity_base_error"):void 0,X1=P&&H?await V(()=>{return I({assetValue:H,memo:A({chain:Y,symbol:R,address:o})})},"core_transaction_add_liquidity_asset_error"):void 0;return{baseAssetTx:Q1,assetTx:X1}}function G({assetValue:z,memo:H,percent:X,type:J}){const{chain:Z,symbol:j}=z,Y=J==="add",R=Y?_1({symbol:j,chain:Z}):G1({basisPoints:Math.min(1e4,Math.round(X*100)),symbol:j,chain:Z});return I({memo:H||R,assetValue:Y?z:u(Z)})}function O({memo:z,assetValue:H,percent:X,from:J,to:Z}){const j=Z==="baseAsset"&&J!=="baseAsset"?Z1.from({chain:_}):J==="sym"&&Z==="sym"||J==="baseAsset"||J==="asset"?void 0:H,Y=u(J==="asset"?H.chain:_),R=z||N1({symbol:H.symbol,chain:H.chain,ticker:H.ticker,basisPoints:Math.min(1e4,Math.round(X*100)),targetAsset:j?.toString()});return I({assetValue:Y,memo:R})}return{addLiquidity:$,addLiquidityPart:Q,approveAssetValue:S,createLiquidity:W,depositToPool:I,getInboundDataByChain:f,isAssetValueApproved:b,nodeAction:F,register:N,registerPreferredAsset:q,savings:G,withdraw:O}}var L1={[c.Average]:1.2,[c.Fast]:1.5,[c.Fastest]:2};import{lowercasedGenericAbiMappings as q1} from"@swapkit/contracts";import{SwapKitError as w} from"@swapkit/helpers";var s=({streamSwap:U,contractAddress:D,recipient:_,toChecksumAddress:L,calldata:B})=>{const f=!!q1[D.toLowerCase()],{amount:M,amountOutMin:E="",data:I="",deadline:S,memo:b,router:N,memoStreamingSwap:q,tcMemo:F,tcRouter:W,tcVault:Q,vault:$,token:G}=B;if(f&&!N)throw new w({errorKey:"thorchain_swapin_router_required",info:B});const O=F||b,z=U?q||O:O;if(!(Q||$))throw new w({errorKey:"thorchain_swapin_vault_required",info:B});if(!(W||N))throw new w({errorKey:"thorchain_swapin_router_required",info:B});if(!z)throw new w({errorKey:"thorchain_swapin_memo_required",info:B});if(!G)throw new w({errorKey:"thorchain_swapin_token_required",info:B});const H=[L(W||N),L(Q||$),z.replace("{recipientAddress}",_),L(G),M],X=f?[L(N),I,S]:[E,S];return[...H,...X]};import{Chain as x1} from"@swapkit/helpers";function p({assetValue:U,from:D,memo:_="",...L}){return{...L,memo:_,from:D,assetValue:U}}var d=({chain:U,address:D})=>{if(!D)return!1;switch(U){case x1.Bitcoin:return!D.startsWith("bc1p");default:return!0}};var P1=function({getWallet:U,stagenet:D=!1}){const{getInboundDataByChain:_,register:L,depositToPool:B,addLiquidity:f,createLiquidity:M,...E}=m({getWallet:U,pluginChain:K.THORChain,stagenet:D,deposit:I});async function I({assetValue:Q,recipient:$,router:G,...O}){const{chain:z,symbol:H,ticker:X}=Q,J=U(z);if(!J)throw new k("core_wallet_connection_not_found");if(!d({address:J.address,chain:z}))throw new k("core_transaction_invalid_sender_address");const j=p({from:J.address,assetValue:Q,recipient:$,router:G,...O});try{switch(z){case K.THORChain:{const Y=U(z);return $===""?Y.deposit(j):Y.transfer(j)}case K.Ethereum:case K.BinanceSmartChain:case K.Avalanche:{const Y=U(z),{getChecksumAddressFromAsset:R}=await import("@swapkit/toolbox-evm"),x=z===K.Avalanche?v1:z===K.BinanceSmartChain?E1:W1;return Y.call({abi:x,contractAddress:G||(await _(z)).router,funcName:"depositWithExpiry",funcParams:[$,R({chain:z,symbol:H,ticker:X},z),Q.getBaseValue("string"),j.memo,O.expiration||Number.parseInt(`${((new Date()).getTime()+900000)/1000}`)],txOverrides:{from:j.from,value:Q.isGasAsset?Q.getBaseValue("bigint"):void 0}})}default:{if(J)return J.transfer(j);throw new k("core_wallet_connection_not_found")}}}catch(Y){const R=typeof Y==="string"?Y.toLowerCase():Y?.message.toLowerCase(),x=R?.includes("insufficient funds"),v=R?.includes("gas"),P=R?.includes("server"),C=R?.includes("user rejected");throw new k(x?"core_transaction_deposit_insufficient_funds_error":v?"core_transaction_deposit_gas_error":P?"core_transaction_deposit_server_error":C?"core_transaction_user_rejected":"core_transaction_deposit_error",Y)}}function S({assetValue:Q,memo:$,minAmount:G,type:O}){return B({assetValue:Q,memo:$||K1(O==="open"?z1.OPEN_LOAN:z1.CLOSE_LOAN,{asset:Q.toString(),minAmount:G.toString(),address:U(Q.chain).address})})}function b({route:Q,...$}){if(!Q)throw new k("core_swap_invalid_params");if("legs"in Q)return q({route:Q,...$});return N({route:Q,...$})}async function N(Q){if(!("route"in Q))throw new k("core_swap_invalid_params");const $=Q.route,{streamSwap:G,recipient:O,feeOptionKey:z}=Q,{meta:{quoteMode:H}}=$,X=H.startsWith("ERC20-")?K.Ethereum:H.startsWith("ARC20-")?K.Avalanche:H.startsWith("BEP20-")?K.BinanceSmartChain:void 0;if(!$.complete)throw new k("core_swap_route_not_complete");if(I1.includes(H)&&X){const J=U(X);if(!J?.sendTransaction)throw new k("core_wallet_connection_not_found");if(!(G?$?.streamingSwap?.transaction:$?.transaction))throw new k("core_swap_route_transaction_not_found");const{data:j,from:Y,to:R,value:x}=$.transaction,v={data:j,from:Y,to:R.toLowerCase(),chainId:BigInt(k1[X]),value:x?BigInt(x):0n};return J.sendTransaction(v,z||e.Average)}if(F1.includes(H)){if(!$.calldata.fromAsset)throw new k("core_swap_asset_not_recognized");const J=await a.from({asset:$.calldata.fromAsset,asyncTokenLookup:!0});if(!J)throw new k("core_swap_asset_not_recognized");const{address:Z}=await _(J.chain),{contract:j,calldata:{expiration:Y,amountIn:R,memo:x,memoStreamingSwap:v}}=$,P=J.add(f1.fromBigInt(BigInt(R),J.decimal));return I({expiration:Y,assetValue:P,memo:G?v||x:x,feeOptionKey:z,router:j,recipient:Z})}if(D1.includes(H)&&X){const{calldata:J,contract:Z}=$;if(!Z)throw new k("core_swap_contract_not_found");const j=U(X),Y=j.address;if(!Y)throw new k("core_wallet_connection_not_found");const{getProvider:R,toChecksumAddress:x}=await import("@swapkit/toolbox-evm"),v=R(X),P=B1[Z.toLowerCase()];if(!P)throw new k("core_swap_contract_not_supported",{contractAddress:Z});const g=await j.createContract(Z,P,v).getFunction("swapIn").populateTransaction(...s({streamSwap:G,toChecksumAddress:x,contractAddress:Z,recipient:O,calldata:J}),{from:Y});return j.sendTransaction(g,z||e.Average)}throw new k("core_swap_quote_mode_not_supported",{quoteMode:H})}async function q({route:Q,feeOptionKey:$}){if(!Q)throw new k("core_swap_invalid_params");const{memo:G,expiration:O,targetAddress:z}=Q,H=await a.from({asset:Q.sellAsset,value:Q.sellAmount,asyncTokenLookup:!0});if(!H)throw new k("core_swap_asset_not_recognized");const{address:X}=await _(H.chain);return I({expiration:Number(O),assetValue:H,memo:G,feeOptionKey:$,router:z,recipient:X})}async function F(Q){const{baseAssetTx:$,assetTx:G}=await f(Q);return{runeTx:$,baseAssetTx:$,assetTx:G}}async function W(Q){const{baseAssetTx:$,assetTx:G}=await M(Q);return{runeTx:$,baseAssetTx:$,assetTx:G}}return{...E,addLiquidity:F,createLiquidity:W,deposit:I,getInboundDataByChain:_,loan:S,registerTHORName:L,swap:b,supportedSwapkitProviders:[H1.THORCHAIN,H1.THORCHAIN_STREAMING],registerThorname:L}},T1={thorchain:{plugin:P1}},r1=T1;import{AssetValue as M1,Chain as h,MayaArbitrumVaultAbi as S1,MayaEthereumVaultAbi as b1,ProviderName as C1,SwapKitError as y} from"@swapkit/helpers";var y1=function({getWallet:U,stagenet:D=!1}){const{getInboundDataByChain:_,register:L,addLiquidity:B,createLiquidity:f,...M}=m({deposit:E,pluginChain:h.Maya,stagenet:D,getWallet:U});async function E({assetValue:N,recipient:q,router:F,...W}){const{chain:Q,symbol:$,ticker:G}=N,O=U(Q);if(!O)throw new y("core_wallet_connection_not_found");const z=O.address;if(!d({address:z,chain:Q}))throw new y("core_transaction_invalid_sender_address");const X=p({from:z,assetValue:N,recipient:q,router:F,...W});try{switch(Q){case h.Maya:{const J=U(Q);return q===""?J.deposit(X):J.transfer(X)}case h.Arbitrum:case h.Ethereum:{const{getChecksumAddressFromAsset:J}=await import("@swapkit/toolbox-evm"),Z=U(Q),j=Q===h.Arbitrum?S1:b1,Y=[q,J({chain:Q,symbol:$,ticker:G},Q),N.getBaseValue("string"),X.memo,W.expiration||Number.parseInt(`${((new Date()).getTime()+900000)/1000}`)],R={from:X.from,value:N.isGasAsset?N.getBaseValue("bigint"):void 0};return await Z.call({abi:j,funcName:"depositWithExpiry",funcParams:Y,txOverrides:R,contractAddress:F||(await _(Q)).router})}default:{if(O)return O.transfer(X);throw new y("core_wallet_connection_not_found")}}}catch(J){const Z=typeof J==="string"?J.toLowerCase():J?.message.toLowerCase(),j=Z?.includes("insufficient funds"),Y=Z?.includes("gas"),R=Z?.includes("server"),x=Z?.includes("user rejected");throw new y(j?"core_transaction_deposit_insufficient_funds_error":Y?"core_transaction_deposit_gas_error":R?"core_transaction_deposit_server_error":x?"core_transaction_user_rejected":"core_transaction_deposit_error",J)}}async function I(N){if(!("route"in N))throw new y("core_swap_invalid_params");const q=N.route,{feeOptionKey:F}=N,{memo:W,expiration:Q,targetAddress:$}=q,G=await M1.from({asset:q.sellAsset,value:q.sellAmount,asyncTokenLookup:!0}),O=G.chain;if(!G)throw new y("core_swap_asset_not_recognized");const{address:z}=await _(O);return E({expiration:Number(Q),assetValue:G,memo:W,feeOptionKey:F,router:$,recipient:z})}async function S(N){const{baseAssetTx:q,assetTx:F}=await B(N);return{cacaoTx:q,baseAssetTx:q,assetTx:F}}async function b(N){const{baseAssetTx:q,assetTx:F}=await f(N);return{cacaoTx:q,baseAssetTx:q,assetTx:F}}return{...M,addLiquidity:S,createLiquidity:b,getInboundDataByChain:_,deposit:E,registerMAYAName:L,swap:I,supportedSwapkitProviders:[C1.MAYACHAIN],registerMayaname:L}},zz={mayachain:{plugin:y1}};export{s as getSwapInParams,r1 as ThorchainProvider,T1 as ThorchainPlugin,zz as MayachainPlugin};

//# debugId=9B18DDA54C12FF4964756E2164756E21
