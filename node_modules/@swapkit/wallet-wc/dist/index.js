var k=((u)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(u,{get:(N,f)=>(typeof require!=="undefined"?require:N)[f]}):u)(function(u){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+u+'" is not supported')});import{Chain as Z} from"@swapkit/helpers";var h="wss://relay.walletconnect.com",l="eip155:1",c="eip155:56",o="eip155:43114",M="cosmos:thorchain",e="cosmos:cosmoshub-4",i="cosmos:kaiyo-1",a="cosmos:mayachain",n="eip155:42161",uu="eip155:10",fu="eip155:137",Nu="debug",ju={name:"THORSwap",description:"THORSwap multi-chain dex aggregator powered by THORChain",url:"https://app.thorswap.finance/",icons:["https://static.thorswap.net/logo.png"]},K;((Y)=>{Y.ETH_SEND_TRANSACTION="eth_sendTransaction";Y.ETH_SIGN="eth_sign";Y.PERSONAL_SIGN="personal_sign";Y.ETH_SIGN_TYPED_DATA="eth_signTypedData"})(K||={});var O;((f)=>{f.ETH_CHAIN_CHANGED="chainChanged";f.ETH_ACCOUNTS_CHANGED="accountsChanged"})(O||={});var H;((J)=>{J.COSMOS_SIGN_DIRECT="cosmos_signDirect";J.COSMOS_SIGN_AMINO="cosmos_signAmino";J.COSMOS_GET_ACCOUNTS="cosmos_getAccounts"})(H||={});var bu;((u)=>{})(bu||={});var d;((f)=>{f.SOL_SIGN_TRANSACTION="solana_signTransaction";f.SOL_SIGN_MESSAGE="solana_signMessage"})(d||={});var C;((u)=>{})(C||={});var s;((f)=>{f.POLKADOT_SIGN_TRANSACTION="polkadot_signTransaction";f.POLKADOT_SIGN_MESSAGE="polkadot_signMessage"})(s||={});var D;((u)=>{})(D||={});var A;((z)=>{z.NEAR_SIGN_IN="near_signIn";z.NEAR_SIGN_OUT="near_signOut";z.NEAR_GET_ACCOUNTS="near_getAccounts";z.NEAR_SIGN_AND_SEND_TRANSACTION="near_signAndSendTransaction";z.NEAR_SIGN_AND_SEND_TRANSACTIONS="near_signAndSendTransactions"})(A||={});var S;((u)=>{})(S||={});var Ju=[Z.Arbitrum,Z.Avalanche,Z.BinanceSmartChain,Z.Cosmos,Z.Ethereum,Z.Kujira,Z.Maya,Z.Optimism,Z.Polygon,Z.THORChain];import{Chain as j,ChainId as yu,RPCUrl as xu,SwapKitError as b,WalletOption as Zu,setRequestClientConfig as Pu} from"@swapkit/helpers";import{SwapKitError as Yu,WalletOption as Ru} from"@swapkit/helpers";import{AbstractSigner as mu} from"@swapkit/toolbox-evm";import{Chain as $} from"@swapkit/helpers";var U=(u,N)=>{return(N.find((Y)=>Y.startsWith(m(u)))||"")?.split(":")?.[2]||""},m=(u)=>{switch(u){case $.Avalanche:return o;case $.BinanceSmartChain:return c;case $.Ethereum:return l;case $.THORChain:return M;case $.Arbitrum:return n;case $.Optimism:return uu;case $.Polygon:return fu;case $.Maya:return a;case $.Cosmos:return e;case $.Kujira:return i;default:return""}};class T extends mu{address;chain;walletconnect;provider;constructor({chain:u,provider:N,walletconnect:f}){super(N);this.chain=u,this.walletconnect=f,this.provider=N,this.address=""}getAddress=async()=>{if(!this.walletconnect)throw new Yu("wallet_walletconnect_connection_not_established");if(!this.address)this.address=U(this.chain,this.walletconnect.accounts);return this.address};signMessage=async(u)=>{const N=await this.walletconnect?.client.request({chainId:m(this.chain),topic:this.walletconnect.session.topic,request:{method:"eth_sign",params:[u]}});return N.startsWith("0x")?N:`0x${N}`};signTransaction=()=>{throw new Error("Not implemented: signTransaction")};signTypedData=()=>{throw new Error("Not implemented: signTypedData")};sendTransaction=async({from:u,to:N,value:f,data:J})=>{const{toHexString:Y}=await import("@swapkit/toolbox-evm"),z={from:u,to:N,value:Y(BigInt(f||0)),data:J};return await this.walletconnect?.client.request({chainId:m(this.chain),topic:this.walletconnect.session.topic,request:{method:"eth_sendTransaction",params:[z]}})};connect=(u)=>{if(!u)throw new Yu({errorKey:"wallet_provider_not_found",info:{wallet:Ru.WALLETCONNECT,chain:this.chain}});return new T({chain:this.chain,walletconnect:this.walletconnect,provider:u})}}var zu=async({chain:u,walletconnect:N,provider:f})=>new T({chain:u,walletconnect:N,provider:f});import{SwapKitError as Qu} from"@swapkit/helpers";var ru=(u)=>{const N=[];for(let f of u){const[J]=f.split(":");if(J&&!N.includes(J))N.push(J)}return N},vu=(u)=>{switch(u){case"eip155":return Object.values(K);case"cosmos":return Object.values(H);case"solana":return Object.values(d);case"polkadot":return Object.values(s);case"near":return Object.values(A);default:throw new Qu({errorKey:"wallet_walletconnect_namespace_not_supported",info:{namespace:u}})}},Mu=(u)=>{switch(u){case"eip155":return Object.values(O);case"cosmos":return[];case"solana":return Object.values(C);case"polkadot":return Object.values(D);case"near":return Object.values(S);default:throw new Qu({errorKey:"wallet_walletconnect_namespace_not_supported",info:{namespace:u}})}},Xu=(u)=>{const N=ru(u);return Object.fromEntries(N.map((f)=>[f,{methods:vu(f),chains:u.filter((J)=>J.startsWith(f)),events:Mu(f)}]))};async function Ku({chain:u,ethplorerApiKey:N,covalentApiKey:f="",walletconnect:J,address:Y,session:z}){switch(u){case j.Avalanche:case j.BinanceSmartChain:case j.Arbitrum:case j.Optimism:case j.Polygon:case j.Ethereum:{if(u===j.Ethereum&&!N)throw new b({errorKey:"wallet_missing_api_key",info:{chain:u,missingApiKey:"ethplorerApiKey"}});if(u!==j.Ethereum&&!f)throw new b({errorKey:"wallet_missing_api_key",info:{chain:u,missingApiKey:"covalentApiKey"}});const{getProvider:Q,getToolboxByChain:I}=await import("@swapkit/toolbox-evm"),X=Q(u),V=await zu({walletconnect:J,chain:u,provider:X});return I(u)({provider:X,signer:V,ethplorerApiKey:N,covalentApiKey:f})}case j.THORChain:{const{SignMode:Q}=await import("cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"),{TxRaw:I}=await import("cosmjs-types/cosmos/tx/v1beta1/tx.js"),{encodePubkey:X,makeAuthInfoBytes:V}=await import("@cosmjs/proto-signing"),{makeSignDoc:G}=await import("@cosmjs/amino"),{ThorchainToolbox:R,buildAminoMsg:g,buildEncodedTxBody:F,createStargateClient:q,fromBase64:y,getDefaultChainFee:r,prepareMessageForBroadcast:p}=await import("@swapkit/toolbox-cosmos"),x=R({stagenet:!1}),v=r(u),w=(B)=>J?.client.request({chainId:M,topic:z.topic,request:{method:"cosmos_signAmino",params:{signerAddress:Y,signDoc:B}}});async function P({assetValue:B,memo:_,...$u}){const W=await x.getAccount(Y);if(!W)throw new b({errorKey:"wallet_missing_params",info:{account:W}});if(!W.pubkey)throw new b({errorKey:"wallet_missing_params",info:{account:W,pubkey:W?.pubkey}});const{accountNumber:Iu,sequence:E=0}=W,t=[g({chain:j.THORChain,assetValue:B,memo:_,from:Y,...$u})],Gu=G(t,v,yu.THORChain,_,Iu?.toString(),E?.toString()||"0"),L=await w(Gu),Bu=await F({chain:j.THORChain,msgs:t.map(p),memo:_||""}),Vu=X(W.pubkey),qu=V([{pubkey:Vu,sequence:E}],v.amount,Number.parseInt(v.gas),void 0,void 0,Q.SIGN_MODE_LEGACY_AMINO_JSON),ku=I.fromPartial({bodyBytes:Bu,authInfoBytes:qu,signatures:[y(typeof L.signature==="string"?L.signature:L.signature.signature)]}),Wu=I.encode(ku).finish();return(await(await q(xu.THORChain)).broadcastTx(Wu)).transactionHash}return{...x,transfer:(B)=>P(B),deposit:(B)=>P(B)}}default:throw new b({errorKey:"wallet_chain_not_supported",info:{chain:u,wallet:Zu.WALLETCONNECT}})}}async function Hu(u,N,f){let J;try{if(!N)throw new b("wallet_walletconnect_project_id_not_specified");const Y=Xu(u.map(m)),{WalletConnectModalSign:z}=await import("@walletconnect/modal-sign-html"),Q=new z({logger:Nu,relayUrl:h,projectId:N,metadata:f?.metadata||ju,...f?.core}),I=await Q.getSession();if(I)await Q.disconnect({topic:I.topic,reason:{code:0,message:"Resetting session"}});const X=await Q.connect({requiredNamespaces:Y}),V=Object.values(X.namespaces).flatMap((R)=>R.accounts);return{session:X,accounts:V,client:Q,disconnect:async()=>{await Q.disconnect({topic:X.topic,reason:{code:0,message:"User disconnected"}})}}}catch(Y){console.error(Y)}finally{if(J)J.closeModal()}return}var Uu=function({addChain:u,config:{thorswapApiKey:N,ethplorerApiKey:f,walletConnectProjectId:J,covalentApiKey:Y,stagenet:z=!1}}){return async function Q(I,X){Pu({apiKey:N});const V=I.filter((q)=>Ju.includes(q)),G=await Hu(V,J,X);if(!G)throw new b("wallet_walletconnect_connection_not_established");const{session:R,accounts:g}=G,F=V.map(async(q)=>{const y=U(q,g),r=await Ku({session:R,address:y,chain:q,walletconnect:G,ethplorerApiKey:f,covalentApiKey:Y,stagenet:z});async function p(x){const v=await r.getAccount(x),[{address:w,algo:P,pubkey:B}]=await G?.client.request({chainId:M,topic:R.topic,request:{method:"cosmos_getAccounts",params:{}}});return{...v,address:w,pubkey:{type:P,value:B}}}u({...r,disconnect:G.disconnect,address:y,balance:[],chain:q,walletType:Zu.WALLETCONNECT,getAccount:q===j.THORChain?p:r.getAccount})});return await Promise.all(F),!0}},iu=[j.BinanceSmartChain,j.Ethereum,j.THORChain,j.Avalanche,j.Arbitrum,j.Optimism,j.Polygon,j.Maya,j.Cosmos,j.Kujira],au={connectWalletconnect:Uu};export{au as walletconnectWallet,Ju as WC_SUPPORTED_CHAINS,M as THORCHAIN_MAINNET_ID,fu as POLYGON_MAINNET_ID,uu as OPTIMISM_MAINNET_ID,a as MAYACHAIN_MAINNET_ID,i as KUJIRA_MAINNET_ID,l as ETHEREUM_MAINNET_ID,d as DEFAULT_SOLANA_METHODS,C as DEFAULT_SOLANA_EVENTS,h as DEFAULT_RELAY_URL,s as DEFAULT_POLKADOT_METHODS,D as DEFAULT_POLKADOT_EVENTS,A as DEFAULT_NEAR_METHODS,S as DEFAULT_NEAR_EVENTS,Nu as DEFAULT_LOGGER,O as DEFAULT_EIP_155_EVENTS,K as DEFAULT_EIP155_METHODS,H as DEFAULT_COSMOS_METHODS,bu as DEFAULT_COSMOS_EVENTS,ju as DEFAULT_APP_METADATA,e as COSMOS_HUB_MAINNET_ID,c as BSC_MAINNET_ID,o as AVALACHE_MAINNET_ID,n as ARBITRUM_ONE_MAINNET_ID};

//# debugId=A232BB21034579AB64756E2164756E21
