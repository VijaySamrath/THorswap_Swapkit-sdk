var F=((z)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(z,{get:(J,Y)=>(typeof require!=="undefined"?require:J)[Y]}):z)(function(z){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+z+'" is not supported')});import{Chain as X,WalletOption as $z,setRequestClientConfig as qz} from"@swapkit/helpers";import{KeepKeySdk as jz} from"@keepkey/keepkey-sdk";import{ChainId as y,DerivationPath as c,RPCUrl as d,derivationPathToString as h} from"@swapkit/helpers";function m(z){if(z==="m/")return!0;return/^m(((\/[0-9]+h)+|(\/[0-9]+H)+|(\/[0-9]+')*)((\/[0-9]+)*))$/.test(z)}function V(z){let J=z;if(!m(J))throw new Error(`Not a bip32 path: '${J}'`);if(/^m\//i.test(J))J=J.slice(2);const Y=J.split("/");if(Y.length===1&&Y[0]==="")return[];const Q=new Array(Y.length);for(let $=0;$<Y.length;$++){const q=Y[$];if(q){const Z=/(\d+)([hH']?)/.exec(q);if(Z===null)throw new Error("Invalid input");const[,W="",G=""]=Z;if(Q[$]=Number.parseInt(W,10),Q[$]>=2147483648)throw new Error("Invalid child index");if(G==="h"||G==="H"||G==="'")Q[$]+=2147483648;else if(G.length!==0)throw new Error("Invalid modifier")}}return Q}var K;((q)=>{q.BTC="Bitcoin";q.BCH="BitcoinCash";q.DOGE="Dogecoin";q.LTC="Litecoin";q.DASH="Dash"})(K||={});var v=async({sdk:z,api:J,derivationPath:Y})=>{const{DEFAULT_COSMOS_FEE_MAINNET:Q,GaiaToolbox:$,createStargateClient:q}=await import("@swapkit/toolbox-cosmos");try{const Z=Y?h(Y):`${c.GAIA}/0`,{address:W}=await z.address.cosmosGetAddress({address_n:V(Z)}),G=$({server:J});if(Q.amount[0])Q.amount[0].amount=String(await G?.getFeeRateFromThorswap?.(y.Cosmos,500));return{...G,transfer:async({assetValue:B,recipient:L,memo:_})=>{const j=B.getBaseValue("string"),R=await G.getAccount(W),U=await z.cosmos.cosmosSignAmino({signerAddress:W,signDoc:{fee:Q,memo:_||"",sequence:R?.sequence.toString()??"",chain_id:y.Cosmos,account_number:R?.accountNumber.toString()??"",msgs:[{value:{amount:[{denom:"uatom",amount:j}],to_address:L,from_address:W},type:"cosmos-sdk/MsgSend"}]}}),H=atob(U.serialized),I=new Uint8Array(H.length).map((D,O)=>H.charCodeAt(O));return(await(await q(d.Cosmos)).broadcastTx(I)).transactionHash},address:W}}catch(Z){throw console.error(Z),Z}};import{ChainToChainId as r,NetworkDerivationPath as o,derivationPathToString as n} from"@swapkit/helpers";import{AbstractSigner as s} from"@swapkit/toolbox-evm";class A extends s{sdk;chain;derivationPath;address;provider;constructor({sdk:z,chain:J,derivationPath:Y,provider:Q}){super();this.sdk=z,this.chain=J,this.derivationPath=Y||o.ETH,this.address="",this.provider=Q}signTypedData(){throw new Error("this method is not implemented")}getAddress=async()=>{if(this.address)return this.address;const{address:z}=await this.sdk.address.ethereumGetAddress({address_n:V(n(this.derivationPath))});return this.address=z,z};signMessage=(z)=>this.sdk.eth.ethSign({address:this.address,message:z});signTransaction=async({to:z,value:J,gasLimit:Y,nonce:Q,data:$,maxFeePerGas:q,maxPriorityFeePerGas:Z,gasPrice:W})=>{if(!z)throw new Error("Missing to address");if(!Y)throw new Error("Missing gasLimit");if(!$)throw new Error("Missing data");const G=!!((q||Z)&&!W);if(G&&!q)throw new Error("Missing maxFeePerGas");if(G&&!Z)throw new Error("Missing maxFeePerGas");if(!(G||W))throw new Error("Missing gasPrice");const{toHexString:M}=await import("@swapkit/toolbox-evm"),B=Q?BigInt(Q):BigInt(await this.provider.getTransactionCount(await this.getAddress(),"pending")),L={gas:M(BigInt(Y)),addressNList:[2147483692,2147483708,2147483648,0,0],from:this.address,chainId:M(BigInt(r[this.chain])),to:z.toString(),value:M(BigInt(J||0)),nonce:M(B),data:$,...G&&{maxFeePerGas:M(BigInt(q?.toString()||"0")),maxPriorityFeePerGas:M(BigInt(Z?.toString()||"0"))},...!G&&{gasPrice:M(BigInt(W?.toString()||"0"))}};return(await this.sdk.eth.ethSignTransaction(L)).serialized};sendTransaction=async(z)=>{if(!this.provider)throw new Error("No provider set");const J=await this.signTransaction(z);return await this.provider.broadcastTransaction(J)};connect=(z)=>new A({sdk:this.sdk,chain:this.chain,derivationPath:this.derivationPath,provider:z})}import{Chain as t,ChainId as a,DerivationPath as i,RPCUrl as k,derivationPathToString as e} from"@swapkit/helpers";var u=async({sdk:z,derivationPath:J})=>{const{createStargateClient:Y,getToolboxByChain:Q}=await import("@swapkit/toolbox-cosmos"),$=Q(t.Maya)(),q=J?e(J):`${i.MAYA}/0`,{address:Z}=await z.address.mayachainGetAddress({address_n:V(q)}),W=async({assetValue:B,recipient:L,from:_,memo:j})=>{const{makeSignDoc:R}=await import("@cosmjs/amino"),{getDenomWithChain:U}=await import("@swapkit/toolbox-cosmos"),H=await $.getAccount(_);if(!H)throw new Error("Account not found");const{accountNumber:I,sequence:w=0}=H,E=B.getBaseValue("string"),D=L&&L!=="",O=D?{type:"mayachain/MsgSend",value:{amount:[{amount:E,denom:B.symbol.toLowerCase()}],from_address:_,to_address:L}}:{type:"mayachain/MsgDeposit",value:{coins:[{amount:E,asset:U(B)}],memo:j,signer:_}},N=R([O],{gas:"500000000",amount:[]},a.Maya,j,I?.toString(),w),S=D?await z.mayachain.mayachainSignAminoTransfer({signDoc:N,signerAddress:_}):await z.mayachain.mayachainSignAminoDeposit({signDoc:N,signerAddress:_}),b=atob(S.serialized);return new Uint8Array(b.length).map((f,T)=>b.charCodeAt(T))};return{...$,transfer:async({assetValue:B,recipient:L,memo:_})=>{const j=await Y(k.Maya),R=await W({assetValue:B,recipient:L,memo:_,from:Z}),{transactionHash:U}=await j.broadcastTx(R);return U},deposit:async({assetValue:B,memo:L})=>{const _=await Y(k.THORChain),j=await W({assetValue:B,memo:L,from:Z}),{transactionHash:R}=await _.broadcastTx(j);return R},address:Z}};import{Chain as P,ChainId as zz,DerivationPath as Jz,RPCUrl as g,derivationPathToString as Qz} from"@swapkit/helpers";var C=async({sdk:z,derivationPath:J})=>{const{makeSignDoc:Y}=await import("@cosmjs/amino"),{buildAminoMsg:Q,getDefaultChainFee:$,createStargateClient:q,ThorchainToolbox:Z}=await import("@swapkit/toolbox-cosmos"),W=Z({stagenet:!1}),G=J?Qz(J):`${Jz.THOR}/0`,{address:M}=await z.address.thorchainGetAddress({address_n:V(G)}),B=async({assetValue:j,recipient:R,from:U,memo:H})=>{const I=await W.getAccount(U);if(!I)throw new Error("Account not found");const{accountNumber:w,sequence:E=0}=I,D=R&&R!=="",O=Q({chain:P.THORChain,from:U,recipient:R,assetValue:j,memo:H}),N=Y([O],$(P.THORChain),zz.THORChain,H,w?.toString(),E),S=D?await z.thorchain.thorchainSignAminoTransfer({signDoc:N,signerAddress:U}):await z.thorchain.thorchainSignAminoDeposit({signDoc:N,signerAddress:U}),b=atob(S.serialized);return new Uint8Array(b.length).map((f,T)=>b.charCodeAt(T))};return{...W,transfer:async({assetValue:j,recipient:R,memo:U})=>{const H=await q(g.THORChain),I=await B({assetValue:j,recipient:R,memo:U,from:M}),{transactionHash:w}=await H.broadcastTx(I);return w},deposit:async({assetValue:j,memo:R})=>{const U=await q(g.THORChain),H=await B({assetValue:j,memo:R,from:M}),{transactionHash:I}=await U.broadcastTx(H);return I},address:M}};import{Chain as x,DerivationPath as Xz,FeeOption as Yz,derivationPathToString as Zz} from"@swapkit/helpers";var l=async({sdk:z,chain:J,derivationPath:Y,apiKey:Q,apiClient:$})=>{if(!(Q||$))throw new Error("UTXO API key not found");const{getToolboxByChain:q}=await import("@swapkit/toolbox-utxo"),Z=q(J)({apiClient:$,apiKey:Q}),W=[x.Bitcoin,x.Litecoin].includes(J)?"p2wpkh":"p2pkh",G=Y?Zz(Y):`${Xz[J]}/0`,M={coin:K[J],script_type:W,address_n:V(G)},{address:B}=await z.address.utxoGetAddress(M),L=async(j,R,U="")=>{const H=j.txOutputs.map((E)=>{const{value:D,address:O,change:N}=E,S=J===x.BitcoinCash?Z.stripToCashAddress(O):O;if(N||O===B)return{addressNList:M.address_n,isChange:!0,addressType:"change",amount:D,scriptType:W};if(S)return{address:S,amount:D,addressType:"spend"};return null}).filter(Boolean),I=(E)=>{return E.filter((D)=>D!==null&&typeof D==="object"&&Object.keys(D).length!==0)};return(await z.utxo.utxoSignTransaction({coin:K[J],inputs:R,outputs:I(H),version:1,locktime:0,opReturnData:U})).serializedTx};return{...Z,signTransaction:L,transfer:async({from:j,recipient:R,feeOptionKey:U,feeRate:H,memo:I,...w})=>{if(!j)throw new Error("From address must be provided");if(!R)throw new Error("Recipient address must be provided");const{psbt:E,inputs:D}=await Z.buildTx({...w,memo:I,feeOptionKey:U,recipient:R,feeRate:H||(await Z.getFeeRates())[U||Yz.Fast],sender:j,fetchTxHex:J}),O=D.map(({value:S,index:b,hash:f,txHex:T})=>({addressNList:M.address_n,scriptType:W,amount:S.toString(),vout:b,txid:f,hex:T||""})),N=await L(E,O,I);return Z.broadcastTx(N)},address:B}};var Rz=function({apis:z,rpcUrls:J,addChain:Y,config:{blockchairApiKey:Q,covalentApiKey:$,ethplorerApiKey:q="freekey",keepkeyConfig:Z,thorswapApiKey:W}}){return async function G(M,B){if(qz({apiKey:W}),!Z)throw new Error("KeepKey config not found");await p(3);const L=await jz.create(Z),_=M.map(async(j,R)=>{const U=B?B[R]:void 0,H=await Wz({sdk:L,apiClient:z[j],rpcUrl:J[j],chain:j,derivationPath:U,covalentApiKey:$,ethplorerApiKey:q,blockchairApiKey:Q});Y({...H,balance:[],chain:j,walletType:$z.KEEPKEY})});return await Promise.all(_),!0}},Pz=[X.Arbitrum,X.Avalanche,X.BinanceSmartChain,X.Bitcoin,X.BitcoinCash,X.Cosmos,X.Dogecoin,X.Dash,X.Ethereum,X.Litecoin,X.Optimism,X.Polygon,X.THORChain,X.Maya],Wz=async({sdk:z,apiClient:J,rpcUrl:Y,chain:Q,derivationPath:$,covalentApiKey:q,ethplorerApiKey:Z,blockchairApiKey:W})=>{const{getProvider:G,getToolboxByChain:M}=await import("@swapkit/toolbox-evm");switch(Q){case X.BinanceSmartChain:case X.Arbitrum:case X.Optimism:case X.Polygon:case X.Avalanche:case X.Ethereum:{if(Q===X.Ethereum&&!Z)throw new Error("Ethplorer API key not found");if(Q!==X.Ethereum&&!q)throw new Error("Covalent API key not found");const B=G(Q,Y),L=new A({sdk:z,chain:Q,derivationPath:$,provider:B}),_=await L.getAddress(),j={api:J,signer:L,provider:B,covalentApiKey:q,ethplorerApiKey:Z};return{address:_,...M(Q)(j)}}case X.Cosmos:return v({sdk:z,derivationPath:$,api:J});case X.THORChain:return C({sdk:z,derivationPath:$});case X.Maya:return u({sdk:z,derivationPath:$});case X.Bitcoin:case X.BitcoinCash:case X.Dash:case X.Dogecoin:case X.Litecoin:return l({apiKey:W,apiClient:J,sdk:z,chain:Q,derivationPath:$});default:throw new Error(`Chain not supported ${Q}`)}},Bz=async(z="http://localhost:1646/spec/swagger.json")=>{try{return(await fetch(z)).status===200}catch(J){return console.error(J),!1}},p=async(z)=>{if(z===0)alert("KeepKey desktop is required for keepkey-sdk, please go to https://keepkey.com/get-started");if(!await Bz())window.location.assign("keepkey://launch"),await new Promise((Y)=>setTimeout(Y,30000)),p(z-1)},gz={connectKeepkey:Rz};export{gz as keepkeyWallet,Bz as checkKeepkeyAvailability,Pz as KEEPKEY_SUPPORTED_CHAINS};

//# debugId=A5195F54B081077C64756E2164756E21
